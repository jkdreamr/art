<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bubble Glass Text</title>
<style>
  body { margin:0; background: radial-gradient(circle, #111, #000); overflow:hidden; }
  #container { width:100vw; height:100vh; display:flex; justify-content:center; align-items:center; }
  #controls { position:absolute; top:20px; left:20px; background:rgba(0,0,0,0.5); color:white; padding:10px; border-radius:8px; z-index:1; }
  button { background:#007bff;color:#fff;border:none;padding:8px 16px;margin:5px;border-radius:4px;cursor:pointer; }
  button:hover { background:#0056b3; }
</style>
</head>
<body>
<div id="controls">
  <div>Bubble Text ü§ç</div>
  <button onclick="toggleRotation()">Toggle Rotation</button>
  <button onclick="changeColor()">Change Color</button>
</div>
<div id="container"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://threejs.org/examples/jsm/loaders/FontLoader.js"></script>
<script src="https://threejs.org/examples/jsm/geometries/TextGeometry.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,1000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
document.getElementById('container').appendChild(renderer.domElement);

// Load cube environment map for reflections
const cubeUrls = ['px.jpg','nx.jpg','py.jpg','ny.jpg','pz.jpg','nz.jpg']; // placeholder HDR set
const cubeTex = new THREE.CubeTextureLoader().setPath('images/cube/').load(cubeUrls);
scene.environment = cubeTex;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(10,10,10);
dir.castShadow = true;
scene.add(dir);
const p1 = new THREE.PointLight(0x88ccff,1,100);
const p2 = new THREE.PointLight(0xff88cc,1,100);
scene.add(p1, p2);

// Glass material
const bubbleMaterial = new THREE.MeshPhysicalMaterial({
  color: 0x88ccff,
  roughness: 0,
  metalness: 0,
  transmission: 1,
  thickness: 1.2,
  ior: 1.45,
  reflectivity: 1,
  clearcoat: 1,
  clearcoatRoughness: 0.05,
  envMap: cubeTex
});

// Load bubble-font and create text
let textMesh, isRotating = true, colors=[0x88ccff,0xff88cc,0x88ff88], colorIndex=0;
new THREE.FontLoader().load('fonts/indieBubble.json', font => {
  const geo = new THREE.TextGeometry('kelix', {
    font, size:4, height:1.2, curveSegments:32,
    bevelEnabled:true,
    bevelThickness:0.4,
    bevelSize:0.8,
    bevelOffset:0,
    bevelSegments:32
  });
  geo.center();
  textMesh = new THREE.Mesh(geo, bubbleMaterial);
  textMesh.castShadow = true;
  textMesh.receiveShadow = true;
  scene.add(textMesh);
});

const particleGeo = new THREE.BufferGeometry();
const count = 150;
const pos = new Float32Array(count * 3);
for(let i=0;i<count*3;i++) pos[i] = (Math.random()-0.5)*50;
particleGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
const pmat = new THREE.PointsMaterial({ size:0.1, color:0x88ccff, transparent:true, opacity:0.6 });
const pmesh = new THREE.Points(particleGeo, pmat);
scene.add(pmesh);

camera.position.set(0,2,20);
let time=0;
function animate(){
  requestAnimationFrame(animate);
  time += 0.01;
  if(textMesh && isRotating){
    textMesh.rotation.set(Math.sin(time*0.5)*0.2, time*0.6, Math.cos(time*0.3)*0.1);
    textMesh.position.y = Math.sin(time*0.8)*0.5;
  }
  pmesh.rotation.y = time*0.1;
  pmesh.rotation.x = time*0.05;
  p1.position.set(Math.sin(time)*20,10,Math.cos(time)*20);
  p2.position.set(Math.cos(time*1.3)*20,10,Math.sin(time*1.3)*20);
  renderer.render(scene, camera);
}

function toggleRotation(){ isRotating = !isRotating; }
function changeColor(){
  if(textMesh){
    colorIndex = (colorIndex+1) % colors.length;
    textMesh.material.color.setHex(colors[colorIndex]);
  }
}

window.addEventListener('mousemove', e=>{
  const mx = (e.clientX/window.innerWidth)*2-1;
  const my = -(e.clientY/window.innerHeight)*2+1;
  if(textMesh){
    textMesh.rotation.x += my*0.001;
    textMesh.rotation.y += mx*0.001;
  }
});

window.addEventListener('resize', _=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

animate();
</script>
</body>
</html>
